腾讯面试 8.22 12：00 面试

美团笔试 8.22 16：00 - 18：00

猿辅导笔试 8.22 19：00 - 20：30

字节跳动笔试 8.23 10：00

爱奇艺笔试 8.23 15：00-17：00（在线测评 8.23之前）

腾讯笔试8.23 20：00-22：00

中金所 8.27 14：00-16：00





面试题总结：



聊项目

介绍下B+树

## 事务的ACID

**原子性（Atomicity）**
原子性是指事务是一个不可分割的工作单位，事务中的操作要么都发生，要么都不发生。
**一致性（Consistency）**
事务前后数据的完整性必须保持一致。
**隔离性（Isolation）**
事务的隔离性是多个用户并发访问数据库时，数据库为每一个用户开启的事务，不能被其他事务的操作数据所干扰，多个并发事务之间要相互隔离。
**持久性（Durability）**
持久性是指一个事务一旦被提交，它对数据库中数据的改变就是永久性的，接下来即使数据库发生故障也不应该对其有任何影响



脏读： 读取未提交的事务

不可重复读：同一事务内两次读取结果不一致

幻读：在事务执行时有插入数据

**隔离级别**

**读未提交**

**读已提交**

**可重复读**

**串行化**

进程通信机制



线程通信机制





# **负载均衡**

springcloud ribbon

**1、轮询法**

　　将请求按顺序轮流地分配到后端服务器上，它均衡地对待后端的每一台服务器，而不关心服务器实际的连接数和当前的系统负载。

**2、随机法**

   通过系统的随机算法，根据后端服务器的列表大小值来随机选取其中的一台服务器进行访问。由概率统计理论可以得知，随着客户端调用服务端的次数增多，

其实际效果越来越接近于平均分配调用量到后端的每一台服务器，也就是轮询的结果。

**3、源地址哈希法**

   源地址哈希的思想是根据获取客户端的IP地址，通过哈希函数计算得到的一个数值，用该数值对服务器列表的大小进行取模运算，得到的结果便是客服端要访问服务器的序号。采用源地址哈希法进行负载均衡，同一IP地址的客户端，当后端服务器列表不变时，它每次都会映射到同一台后端服务器进行访问。

**4、加权轮询法**

　　不同的后端服务器可能机器的配置和当前系统的负载并不相同，因此它们的抗压能力也不相同。给配置高、负载低的机器配置更高的权重，让其处理更多的请；而配置低、负载高的机器，给其分配较低的权重，降低其系统负载，加权轮询能很好地处理这一问题，并将请求顺序且按照权重分配到后端。

**5、加权随机法**

   与加权轮询法一样，加权随机法也根据后端机器的配置，系统的负载分配不同的权重。不同的是，它是按照权重随机请求后端服务器，而非顺序。

**6、最小连接数法**

   最小连接数算法比较灵活和智能，由于后端服务器的配置不尽相同，对于请求的处理有快有慢，它是根据后端服务器当前的连接情况，动态地选取其中当前

积压连接数最少的一台服务器来处理当前的请求，尽可能地提高后端服务的利用效率，将负责合理地分流到每一台服务器。





# HTTP长连接和短连接

# TCP拥塞控制

**慢开始**

**拥塞避免**

**快重传**

**快恢复**

# Java会出现内存泄露吗

**会**  **长生命周期对象持有短生命周期对象时，内部类等**

# 1TB的数据如何进行排序

**先分块在内存中排序，再拿出来外部归并排序**

# Java的GC中什么场景下使用CMS和G1

# 线程的状态

线程共包括以下 5 种状态:

**1. 新建状态(New):** 线程对象被创建后，就进入了新建状态。例如，Thread thread = new Thread()。

**2. 就绪状态(Runnable):** 也被称为“可执行状态”。线程对象被创建后，其它线程调用了该对象的start()方法，从而来启动该线程。例如，thread.start()。处于就绪状态的线程，随时可能被CPU调度执行。

**3. 运行状态(Running):** 线程获取CPU权限进行执行。需要注意的是，线程只能从就绪状态进入到运行状态。

**4. 阻塞状态(Blocked):** 阻塞状态是线程因为某种原因放弃CPU使用权，暂时停止运行。直到线程进入就绪状态，才有机会转到运行状态。阻塞的情况分三种：

- (01) 等待阻塞 -- 通过调用线程的wait()方法，让线程等待某工作的完成。
- (02) 同步阻塞 -- 线程在获取synchronized同步锁失败(因为锁被其它线程所占用)，它会进入同步阻塞状态。
- (03) 其他阻塞 -- 通过调用线程的sleep()或join()或发出了I/O请求时，线程会进入到阻塞状态。当sleep()状态超时、join()等待线程终止或者超时、或者I/O处理完毕时，线程重新转入就绪状态。

**5. 死亡状态(Dead):** 线程执行完了或者因异常退出了run()方法，该线程结束生命周期。

# TCP三次握手的backlog什么作用？

backlog这个参数值和三次握手的概念有着密切关联。backlog队列大小 = 未完成三次握手队列 +  已经完成三次握手队列。


未完成三次握手队列：服务器处于listen状态时，收到客户端syn报文（connect）时放入未完成队列中。



已完成三次握手队列：三次握手的第二个状态即服务器syn+ack响应client后，此时第三个状态ack报文到达前（客户端对服务器syn的ack）一直保留在未完成连接队列中。若三次握手完成，该条目将从未完成连接队列搬到已完成连接队列尾部。当server调用accept时，从已完成三次握手队列中的头部取出一个socket连接给进程。


backlog参数设置既可在linux内核参数设置(修改文件/etc/sysctl相关参数)，也可在socket系统调用listen函数时设置(第二个参数)。这二者区别是前者为全局性的，影响所有socket，后者为局部性的，影响当前socket。



若backlog设置过小可能会出现以下情况：server的accpet速度跟不上，导致A、B队列满了，导致新的客户端无法连接。

# **Redis的的key是用什么hash算法映射的？sds是怎么设计的？**

SDS 主要是一个结构体，

1. 
   struct sdshdr {
2. ​    *// buf 已占用长度*
3. ​    int len;
4. ​    *// buf 剩余可用长度*
5. ​    int free;
6. ​    *// 实际保存字符串数据的地方*
7. ​    *// 利用c99(C99 specification 6.7.2.1.16)中引入的 flexible array member,通过buf来引用sdshdr后面的地址，*
8. ​    *// 详情google "flexible array member"*
9. ​    char buf[];
10. 

**责任链模式**

NIO、AIO、BIO

持久化有哪几种方式，怎么选？

AOF 和RDB